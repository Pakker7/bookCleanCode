### 동시성

쓰레드를 아직 써본적이 없다?!
쓰레드를 공부하고나서 나머지 해야지..

- 동시성에 대한 사실
  - 동시성은 항상 성능을 높여주지 않는다.
    - 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다
  - 동시성을 구현하면 설계가 변한다 
    - 스레드 추가시 **무엇** 과 **언제**를 분리해야한다. 그럼 설계가 달라질 수 있다
  - 웹 또는 EJB컨테이너 사용시에도 동시성 이해가 필요하다.
  - 동시성은 다소 부하를 유발
  - 동시성은 복잡하다. 간단한 문제라도 복잡함
  - 일반적으로 동시성 버그는 재현이 어렵다
    - 진짜 결함으로 간주되지 않고, 일회성으로 여겨져 넘어갈수 있다.
  - 동시성 구현은 근본적인 설계전략을 재고해야한다.
  
스레드는 꼭 독립적인 코드로 구현해라

- 스레드 환경에서 사용해도 안전한 컬렉션이 있다.
  - java.util.concurent
  - java.util.concurrent.atomic
  - java.util.cocurrent.locks
  
- 스레드 환경의 실행모델
  - 한정된 자원 (Bound Resource)
    - 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다.
  - 상호 배제 (MutualExclusion)
    - 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
  - 기아(Starvation) 
    - 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. 예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적
으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다.
  - 데드락 (Deadlock) 
    - 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
  - 라이브락(Livelock) 
    - 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(resonanoe》으로 인해, 굉장히 오랫동안 혹은 영원히 진행
하지 못한다.

- 실제 실행 모델에서 문제가 생기는 순서.. 
  - 생산자-소비자
    - 생산자, 소비자, 둘을 잇는 대기열(한정된 자원)
      - 1. 생산자 스레드는 대기열에 빈공간이 있는지 확인 후 비었으면 채운다.
      - 2. 생산자 스레드가 소비자 스레드에게 시그널을 보낸다.
      - 3. 소비자 스레드는 대기열에 빈 공간이 있다는 시그널을 보낸다.
    - 잘못하면 둘다 시그널만 보내면서 기다릴 가능성이 있다..
  - 읽기-쓰기
    - 읽기 쓰레드는 공유자원 사용, 쓰기 쓰레드가 공유자원을 갱신한다 라고 했을 때
    - 처리율의 문제
      - 처리율 강조하면 기아 현상이 생김
      - 갱신 허용하면 처리율에 영향을 미침
    - 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법 -> 하지만.. 쓰기 스레드에게 우선권을 준 상태에서 쓰기 스레드가 계속 이어진다면 처리율이 떨어짐..
  - 식사하는 철학자들
    - ex. 둥근식탁에 철학자 한무리, 각 철학자 왼쪽에는 포크가 놓여있다. 식탁 가운데는 커다란 스파게티 한 접시가 놓였다. 철학자들은 배가 고프지 않으면 생각하며 시간을 보낸다. 배가고프면 양손에 포크를 들고 스파게티 먹는다. 양손에 포크 없으면 스파게티를 못먹음..
    - 철학자 : 스레드 / 포크 : 자원 ..
 
- 동기화 하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다. (synchronized 사용)

- 공유 객체에서 여러 메소드 필요한 경우 방법
  - 1. 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드를호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다.
  - 2. 서버 에서 잠금 - 서버 에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는” 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.
  - 3. 연결Adapted 서버 - 잠금을 수행하는 중간 단계를 생성한다. ‘서버에서 잠금’방식과 유사하지만 원래 서버는 변경하지 않는다.

